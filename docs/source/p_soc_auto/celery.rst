Celery Details
==============

See :ref:`Mail Collector Celery Details` for a more detailed description about
implementing ``Celery Tasks``.

We are using a dedicated `Celery
<https://docs.celeryproject.org/en/latest/index.html>`_
`worker <https://docs.celeryproject.org/en/latest/userguide/workers.html>`_
for each ``queue`` defined under the
:attr:`p_soc_auto.settings.CELERY_QUEUES` setting.

There is a dedicated `Celery
<https://docs.celeryproject.org/en/latest/index.html>`_
`worker <https://docs.celeryproject.org/en/latest/userguide/workers.html>`_ for
``email`` operations that is (or should be) shared between the ``Django``
applications defined by the :ref:`SOC Automation Server`.

There is a dedicated `Celery
<https://docs.celeryproject.org/en/latest/index.html>`_
`worker <https://docs.celeryproject.org/en/latest/userguide/workers.html>`_ for
each ``Django`` application defined by the :ref:`SOC Automation Server`.

There is also a dedicated `Celery
<https://docs.celeryproject.org/en/latest/index.html>`_
`worker <https://docs.celeryproject.org/en/latest/userguide/workers.html>`_ 
shared between the ``Django`` applications defined by the
:ref:`SOC Automation Server`.

Task scheduling in ``Celery``
-----------------------------

By design most of the `Celery tasks
<http://docs.celeryproject.org/en/latest/userguide/tasks.html>`_
implemented in the :ref:`SOC Automation Server` applications are not invoked
directly, they are invoked by an independent scheduling system.

The scheduling system is implemented using `Celery Periodic Tasks
<https://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html?highlight=beat>`_,
a.k.a. ``Celery Beat`` with `Custom Scheduler Classes
<https://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html?highlight=beat#id8>`_.

The ``Custom Scheduler Classes`` used by the :ref:`SOC Automation Server`
applications are implemented via the `django-celery-beat
<https://pypi.python.org/pypi/django-celery-beat/>`_ package. This package
allows us to store schedules in an ``SQL`` database, in this case, in the
:ref:`MariaDB database <MAriaDB Details>` used by the :ref:`SOC Automation
Server`. Another advantage provided by the `django-celery-beat
<https://pypi.python.org/pypi/django-celery-beat/>`_ package is the integration
with the `Django admin interface <https://docs.djangoproject.com/en/2.2/ref/contrib/admin/>`_.
This provided a very simple, if not very easy to use, Web console interface for
configuring ``Celery Periodic Tasks``. See `Periodic Tasks adminsitration
<../../../admin/django_celery_beat/>`_, `Periodic Tasks
<../../../admin/django_celery_beat/periodictask/>`_, `Crontabs
<../../../admin/django_celery_beat/crontabschedule/>`_, and `Intervals
<../../../admin/django_celery_beat/intervalschedule/>`_.

We recommend that all ``Celery Periodic Tasks`` used by the :ref:`SOC
Automation Server` be created by way of `Django Data Migrations
<https://docs.djangoproject.com/en/2.2/topics/migrations/#data-migrations>`_.
This will avoid laboriuous data entry operations by (potentially) untrained
``SOC`` personell, and it will also ensure speedy deployments for new versions
of the :ref:`SOC Automation Server`. Here is a sample of such a migation:

.. code-block:: python

    # Generated by Django 2.1.4 on 2019-06-19 17:37
    import pytz
    from django.db import migrations
    
    
    def add_beats(apps, schema_editor):
        timezone = pytz.timezone('America/Vancouver')
    
        periodic_tasks = [
            {
                'name': ('Raise warning alert for exchange servers'),
                'task': 'mail_collector.tasks.bring_out_your_dead',
                'args': (
                    '["mail_collector.exchangeserver","last_updated__lte",'
                    '"Exchange Servers Not Seen"]'),
                'kwargs': (
                    '{"url_annotate": false,'
                    '"level": "WARNING",'
                    '"filter_pref": "exchange__server_warn",'
                    '"by_mail": true, "to_orion": false, "enabled": true}'),
                'interval': {
                    'every': 30,
                    'period': 'minutes',
                },
            },
    
        ]
    
        cron_tasks = [
            {
                'name': ('Dead exchange servers report'),
                'task': 'mail_collector.tasks.bring_out_your_dead',
                'args': (
                    '["mail_collector.exchangeserver","last_updated__lte",'
                    '"Exchange Servers Not Seen"]'),
                'kwargs': (
                    '{"url_annotate": true,'
                    '"level": null,'
                    '"filter_pref": "exchange__report_interval",'
                    '"by_mail": true, "to_orion": false, "enabled": true}'),
                'crontab': {
                    'minute': '45',
                    'hour': '07,15,23',
                    'day_of_week': '*',
                    'day_of_month': '*',
                    'month_of_year': '*',
                    'timezone': timezone,
                },
            },
        ]
    
        CrontabSchedule = apps.get_model('django_celery_beat', 'CrontabSchedule')
        IntervalSchedule = apps.get_model(
            'django_celery_beat', 'IntervalSchedule')
        PeriodicTask = apps.get_model('django_celery_beat', 'PeriodicTask')
    
        for _task in cron_tasks:
            cron, _ = CrontabSchedule.objects.get_or_create(**_task['crontab'])
    
            _task['crontab'] = cron
    
            PeriodicTask.objects.create(**_task)
    
        for _task in periodic_tasks:
            interval, _ = IntervalSchedule.objects.get_or_create(
                **_task['interval'])
    
            _task['interval'] = interval
    
            PeriodicTask.objects.create(**_task)
    
    
    class Migration(migrations.Migration):
    
        dependencies = [
            ('mail_collector', '0017_add_mail_function_subscriptions'),
        ]
    
        operations = [
            migrations.RunPython(add_beats,
                                 reverse_code=migrations.RunPython.noop)
        ]


The ``Celery Beat`` service
^^^^^^^^^^^^^^^^^^^^^^^^^^^

We have defined a dedicated ``systemd Linux service`` for running the
schedulers used by the :ref:`SOC Automation Server` :ref:`Celery Periodic Tasks
<Celery Details>`. The ``.service`` file for this ``Linux sevice`` is under
source control at configs/celery/phsa_celery_beat.service``.

.. literalinclude:: ../../../configs/celery/phsa_celery_beat.service
   :language: cfg


Throttling the ``Celery Beat`` service
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We have observerd that sometimes, under production conditions, the
``Celery Beat`` service will start consumming a vary large amount of host
resources.
We are controlling this by using the `Monit <https://mmonit.com/monit/>`_
utility.
The file desribing this operation the the `Monit <https://mmonit.com/monit/>`_
daemon is under source control at configs/monit/celery-beat. This file needs to
besymlinked or copied to ``/etc/monit.d/``.

.. literalinclude:: ../../../configs/monit/celery-beat
   :language: cfg


Monitoring ``Celery Tasks`` execution
-------------------------------------

Currently, we are monitoring ``Celery Tasks`` using `Flower
<https://docs.celeryproject.org/en/latest/userguide/monitoring.html?highlight=flower#flower-real-time-celery-web-monitor>`_.

The ``Flower`` service is exposed on the network address of the :ref:`SOC
Automation Server` on port 5555.

The ``Flower`` service runs as a ``systemd Linux service`` configured via the
source controlled file ``configs/celery/phsa_celery_flower.service``.

.. literalinclude:: ../../../configs/celery/phsa_celery_flower.service
   :language: cfg
   
See the usual suspects for enabling and controlling the ``Flower`` service.

`Celery` scaling
----------------

To be determined...

`Celery` security
-----------------

At a miminum,we need to use non-default credentials in the
:attr:`p_soc_auto.settings.CELERY_BROKER_URL`.

`Celery` supports `SSL
<https://docs.celeryproject.org/en/latest/userguide/configuration.html#broker-use-ssl>`_
with the default transport (`pyamqp`) for the `AMPQ <https://www.amqp.org/>`_
protocol.
Sill, enabling `SSL` between the `Celery workers` and the
:ref:`RabbitMQ Server` must be a separate, dedicated effort. 
